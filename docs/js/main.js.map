{"version":3,"names":[],"mappings":"","sources":["src/js/main.js"],"sourcesContent":["/* jshint esversion: 6 */\n/* global window, document, TweenMax, THREE, WEBVR */\n\n// import * as THREE from 'three';\n//import { threadId } from 'worker_threads';\n\nimport * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\nimport { RoughnessMipmapper } from 'three/examples/jsm/utils/RoughnessMipmapper.js';\nimport InteractiveMesh from './interactive/interactive.mesh';\n\nclass webvr {\n\n\tconstructor() {\n\t\tthis.i = 0;\n\t\tthis.mouse = { x: 0, y: 0 };\n\t\tthis.parallax = { x: 0, y: 0 };\n\t\tthis.size = { width: 0, height: 0, aspect: 0 };\n\t\tthis.cameraDirection = new THREE.Vector3();\n\t\tthis.init();\n\t}\n\n\tinit() {\n\t\tthis.render = this.render.bind(this);\n\n\t\tconst section = this.section = document.querySelector('.webvr');\n\t\tconst container = this.container = section.querySelector('.webvr__container');\n\t\tconst debugInfo = this.debugInfo = section.querySelector('.debug__info');\n\n\t\tconst scene = this.scene = new THREE.Scene();\n\n\t\tconst camera = this.camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 0.1, 1000);\n\t\tcamera.position.set(-1.8, 0.6, 2.7);\n\t\tcamera.target = new THREE.Vector3();\n\n\t\tconst light1 = new THREE.PointLight(0xffffff, 3, 100);\n\t\tconst light2 = new THREE.PointLight(0xffffff, 3, 100);\n\t\t// Specify the light's position\n\t\tlight1.position.set(-10 , 10, 10);\n\t\tlight2.position.set(1, 1, 10);\n\t\t// Add the light to the scene\n\t\tscene.add(light1)\n\t\tscene.add(light2)\n\n\t\tconst renderer = this.renderer = new THREE.WebGLRenderer({ antialias: true });\n\t\trenderer.setClearColor(0xffffff, 1);\n\t\trenderer.setPixelRatio(window.devicePixelRatio);\n\t\trenderer.setSize(container.offsetWidth, container.offsetHeight);\n\t\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\t\trenderer.toneMappingExposure = 0.6;\n\t\trenderer.outputEncoding = THREE.sRGBEncoding;\n\t\tcontainer.appendChild(renderer.domElement);\n\n\t\tconst controls = this.controler = new OrbitControls(camera, renderer.domElement);\n\t\tcontrols.addEventListener('change', this.render); // use if there is no animation loop\n\t\tcontrols.minDistance = 2;\n\t\tcontrols.maxDistance = 10\n\t\tcontrols.target.set(0, 0, -0.2);\n\t\tcontrols.update();\n\n\t\tconst pivot = this.pivot = new THREE.Group();\n\t\tthis.scene.add(pivot);\n\n\t\tthis.loadRgbeBackground('/StoreView/textures/equirectangular/', 'industrial_pipe_and_valve_02_2k.hdr', (envMap) => {\n\t\t\tthis.render();\n\t\t\tthis.loadGltfModel('/StoreView/models/gltf/model/gltf/', 'stufa.glb', (model) => {\n\t\t\t\tpivot.scale.set(25, 25, 25);\n\t\t\t\tpivot.position.set(0, 0, 0); //-0.5\n\t\t\t\tpivot.add(model);\n\t\t\t\tthis.render();\n\t\t\t});\n\t\t});\n\n\t\tthis.onWindowResize = this.onWindowResize.bind(this);\n\t\twindow.addEventListener('resize', this.onWindowResize, false);\n\t}\n\n\tloadRgbeBackground(path, file, callback) {\n\t\tconst scene = this.scene;\n\t\tconst renderer = this.renderer;\n\t\tconst pmremGenerator = new THREE.PMREMGenerator(renderer);\n\t\tpmremGenerator.compileEquirectangularShader();\n\t\tconst loader = new RGBELoader();\n\t\tloader\n\t\t\t.setDataType(THREE.UnsignedByteType)\n\t\t\t.setPath(path)\n\t\t\t.load(file, function (texture) {\n\t\t\t\tconst envMap = pmremGenerator.fromEquirectangular(texture).texture;\n\t\t\t\t//scene.background = envMap;\n\t\t\t\tscene.environment = envMap;\n\t\t\t\ttexture.dispose();\n\t\t\t\tpmremGenerator.dispose();\n\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\tcallback(envMap);\n\t\t\t\t}\n\t\t\t});\n\t\treturn loader;\n\t}\n\n\tloadGltfModel(path, file, callback) {\n\t\tconst renderer = this.renderer;\n\t\tconst roughnessMipmapper = new RoughnessMipmapper(renderer); // optional\n\t\tconst loader = new GLTFLoader().setPath(path);\n\t\tloader.load(file, function (gltf) {\n\t\t\tgltf.scene.traverse(function (child) {\n\t\t\t\tif (child.isMesh) {\n\t\t\t\t\troughnessMipmapper.generateMipmaps(child.material);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (typeof callback === 'function') {\n\t\t\t\tcallback(gltf.scene);\n\t\t\t}\n\t\t\troughnessMipmapper.dispose();\n\t\t});\n\t}\n\n\tupdateRaycaster() {\n\t\ttry {\n\t\t\t/*\n\t\t\tconst controllers = this.controllers;\n\t\t\tconst controller = controllers.controller;\n\t\t\tif (controller) {\n\t\t\t\tconst raycaster = this.raycaster;\n\t\t\t\tconst position = controller.position;\n\t\t\t\tconst rotation = controller.getWorldDirection(controllers.controllerDirection).multiplyScalar(-1);\n\t\t\t\traycaster.set(position, rotation);\n\t\t\t\tconst hit = InteractiveMesh.hittest(raycaster, controllers.gamepads.button);\n\t\t\t}\n\t\t\t*/\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\trender(delta) {\n\t\ttry {\n\t\t\t// this.updateOld();\n\t\t\tconst renderer = this.renderer;\n\t\t\trenderer.render(this.scene, this.camera);\n\t\t\tthis.i++;\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tanimate() {\n\t\tconst renderer = this.renderer;\n\t\trenderer.setAnimationLoop(() =>\n\t\t\tthis.render());\n\t}\n\n\tonWindowResize() {\n\t\ttry {\n\t\t\tconst container = this.container,\n\t\t\t\trenderer = this.renderer,\n\t\t\t\tcamera = this.camera;\n\t\t\tconst size = this.size;\n\t\t\tsize.width = container.offsetWidth;\n\t\t\tsize.height = container.offsetHeight;\n\t\t\tsize.aspect = size.width / size.height;\n\t\t\tif (renderer) {\n\t\t\t\trenderer.setSize(size.width, size.height);\n\t\t\t}\n\t\t\tif (camera) {\n\t\t\t\tcamera.aspect = size.width / size.height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tinitOld__() {\n\t\t\n\t\t\n\t}\n\n\tloadObjects__() {\n\t\t\n\t}\n\n\tupdateOld__() {\n\t\tconst s = 1 + Math.cos(this.i * 0.1) * 0.5;\n\t\tif (this.cuber) {\n\t\t\tthis.cube.rotation.y += Math.PI / 180 * 5;\n\t\t\tthis.cube.rotation.x += Math.PI / 180 * 1;\n\t\t\tthis.cube.scale.set(s, s, s);\n\t\t}\n\t\tif (this.prisme) {\n\t\t\tthis.prisme.rotation.y += Math.PI / 180 * 5;\n\t\t\tthis.prisme.rotation.x += Math.PI / 180 * 1;\n\t\t\tthis.prisme.scale.set(s, s, s);\n\t\t}\n\t\t\n\t\tif (this.controllers) {\n\t\t\tthis.controllers.update();\n\t\t}\n\t\tthis.updateRaycaster();\n\t}\n\n}\n\nconst tour = new webvr();\ntour.animate();\n"],"file":"docs\\js\\main.js"}